---
title: 图论测试
tags: 
  - 功能测试
categories:
  - 功能测试
date: 2020-03-04
layout: slides
slide:
  theme: white
---



# 差分约束，二分匹配 ， 2-sat

---

## 差分约束

--

**差分约束系统** 是一种特殊的 $ n $ 元一次不等式组，它包含 $n$ 个变量 $x_1,x_2,...,x_n$ 以及 $m$ 个约束条件，每个约束条件是由两个其中的变量做差构成的，形如 $x_i-x_j\leq c_k$ ，其中 $c_k$ 是常数（可以是非负数，也可以是负数）。我们要解决的问题是：求一组解 $x_1=a_1,x_2=a_2,...,x_n=a_n$ ，使得所有的约束条件得到满足，否则判断出无解。

--

差分约束系统中的每个约束条件 $x_i-x_j\leq c_k$ 都可以变形成 $x_i\leq x_j+c_k$ ，这与单源最短路中的三角形不等式 $dist[y]\leq dist[x]+z$ 非常相似。因此，我们可以把每个变量 $x_i$ 看做图中的一个结点，对于每个约束条件 $x_i-x_j\leq c_k$ ，从结点 $j$ 向结点 $i$ 连一条长度为 $c_k$ 的有向边。

--

注意到，如果 $\{a_1,a_2,...,a_n\}$ 是该差分约束系统的一组解，那么对于任意的常数 $d$ ， $\{a_1+d,a_2+d,...,a_n+d\}$ 显然也是该差分约束系统的一组解，因为这样做差后 $d$ 刚好被消掉。

--

设 $dist[0]=0$ 并向每一个点连一条边，跑单源最短路，若图中存在负环，则给定的差分约束系统无解，否则， $x_i=dist[i]$ 为该差分约束系统的一组解。

一般使用 Bellman-Ford 或队列优化的 Bellman-Ford（俗称 SPFA，在某些随机图跑得很快）判断图中是否存在负环，最坏时间复杂度为 $O(nm)$ 。

--

## 常用变形技巧

--

### 例题[luogu P1993 小 K 的农场](https://www.luogu.org/problemnew/show/P1993)

题目大意：求解差分约束系统，有 $m$ 条约束条件，每条都为形如 $x_a-x_b\geq c_k$ ， $x_a-x_b\leq c_k$ 或 $x_a=x_b$ 的形式，判断该差分约束系统有没有解。

--

|          题意          |                       转化                      |                连边               |
| :------------------: | :-------------------------------------------: | :-----------------------------: |
|  $x_a - x_b \geq c$  |              $x_b - x_a \leq -c$              |         `add(a, b, -c);`        |
|  $x_a - x_b < c$  |               $x_a - x_b \leq c-1$              |         `add(b, a, c-1);`         |
|      $x_a = x_b$     |  $x_a - x_b \leq 0, \space x_b - x_a \leq 0$  |  `add(b, a, 0), add(a, b, 0);`  |

跑判断负环，如果不存在负环，输出 `Yes` ，否则输出 `No` 。

--

# 最长路

也可以改成 $\ge$,不过要求最长路，初始值-INF
|          题意          |                       转化                      |                连边               |
| :------------------: | :-------------------------------------------: | :-----------------------------: |
|  $x_a - x_b \leq c$  |              $x_b - x_a \geq -c$              |         `add(a, b, -c);`        |
|  $x_a - x_b > c$  |               $x_a - x_b \geq c+1$              |         `add(b, a, c+1);`         |
|      $x_a = x_b$     |  $x_a - x_b \leq 0, \space x_b - x_a \leq 0$  |  `add(b, a, 0), add(a, b, 0);`  |

---


# 二分匹配

--

交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。

增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。

--

增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。

--

```cpp
bool findp(int now)
{
    for(int i = head[now];~i;i = edge[i].next)
    {
        int to = edge[i].v;
        if(!vis[to])
        {
            vis[to] = true;
            if(matching[to] == -1 || findp(matching[to]))
            {
                matching[now] = to;
                matching[to] = now;
                return true;
            }
        }
    }
    return false;
}

```

--

```cpp
int hung(int n)
{
   int ans = 0;
   for(int i = 1;i <= n ;i++)
   {
       if(matching[i] == -1){
            memset(vis,0,sizeof(vis));
            if(findp(i))ans++;
       }
   }
   return ans;
}
```

---

## 2-SAT

> SAT 是适定性（Satisfiability）问题的简称。一般形式为 k - 适定性问题，简称 k-SAT。而当 $k>2$ 时该问题为 NP 完全的。所以我们之研究 $k=2$ 的情况。

--


## 定义

2-SAT，简单的说就是给出 $n$ 个集合，每个集合有两个元素，已知若干个 $<a,b>$ ，表示 $a$ 与 $b$ 矛盾（其中 $a$ 与 $b$ 属于不同的集合）。然后从每个集合选择一个元素，判断能否一共选 $n$ 个两两不矛盾的元素。显然可能有多种选择方案，一般题中只需要求出一种即可。

--

## 现实意义

比如邀请人来吃喜酒，夫妻二人必须去一个，然而某些人之间有矛盾（比如 A 先生与 B 女士有矛盾，C 女士不想和 D 先生在一起），那么我们要确定能否避免来人之间没有矛盾，有时需要方案。这是一类生活中常见的问题。

--

使用布尔方程表示上述问题。设 $a$ 表示 A 先生去参加，那么 B 女士就不能参加（ $\neg a$ )； $b$ 表示 C 女士参加，那么 $\neg b$ 也一定成立（D 先生不参加）。总结一下，即 $(a \vee b)$ （变量 $a, b$ 至少满足一个）。对这些变量关系建有向图，则有： $\neg a\Rightarrow b\wedge\neg b\Rightarrow a$ （ $a$ 不成立则 $b$ 一定成立；同理， $b$ 不成立则 $a$ 一定成立）。建图之后，我们就可以使用缩点算法来求解 2-SAT 问题了。

---

# END?


