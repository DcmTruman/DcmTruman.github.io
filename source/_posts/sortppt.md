---
title: 排序
tags: 
  - slides
  - 课件
categories:
  - 课件
date: 2019-11-14
layout: slides
slide:
  theme: white
---

# 排序

---

# what？什么是排序？

--

一言以蔽之 ： 将一个序列按照某个特定的顺序排序，可以是从小到大，也可以是从大到小，也可以更复杂

---

# why？为什么要排序

--

- 打牌？
- 学生成绩排名？
- 合理地动归/贪心？
- 按顺序扫描每个数据？

--

排序是一种手段和工具，在某些最优解问题下可以给我们一定的思路

--

例1 ： 给一个长度为$n$的数列A，$a_{1} , a_{2},...a_{n}$，和长度为$n$的数列B，$b_{1},b_{2},...b_{n}$，让你各自从中挑一个数，$a$和$b$，使得$a + b$既不属于A，也不属于B

--

例2 ：夏天到了，商店要进行促销活动。商店在夏天中营业 n 天。

每天出售的商品数已经确定，第i天出售 ki 件商品，有 li 个客户回来购买。已知每个客户恰好购买一件商品。如果没有商品可以购买，那客户就会选择空手离开。

由于要进行促销，你可以选择 其中f天将出售的商品数翻倍，但是客户的数量不会翻倍。现在让你求出最多能卖出多少件商品。

---

# How?如何排序？


--

## 排序方式

- **冒泡排序**
- **选择排序**
- **插入排序**
- **归并排序**
- **快速排序**
- **计数排序**

--

- **基数排序**
- 堆排序
- 希尔排序
- ......
- [排序可视化](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)

--

既然有这么多方式，那么我应该用哪一种？

--

卖个关子>_<~

---

## 冒泡排序

--

算法如其名，想象一个冒泡泡的过程(￣▽￣)~*

冒泡排序是一种简单的交换类排序方法，它是通过相邻的数据元素的交换，逐步将待排序序列变成有序序列的过程。<(￣︶￣)>

--

### 冒泡排序的基本思想

- 从头扫描待排序记录序列，在扫描的过程中顺次比较相邻的两个元素的大小。

--

- 以升序为例：在第1趟排序中对n个记录进行如下操作 ：
  -  若相邻的两个记录的关键字比较，逆序就**交换位置**。
  -  在扫描的过程中，不断的将相邻两个记录中关键字大的记录向后移动，最后将待排序记录序列中的最大关键字记录换到了待排序记录序列的末尾，这也是最大关键字记录应在的位置。
  
--

  -  然后进行第2趟冒泡排序，对前n-1个记录（最大的数像气泡一样“消失”了）进行同样的操作，其结果是使次大的记录被放在第n-1个记录的位置上。
  -  如此反复，直到排好序为止（若在某一趟冒泡过程中，没有发现一个逆序，则可结束冒泡排序），所以 冒泡过程最多进行n-1趟。

--

### 冒泡排序算法分析

最坏情况下，待排序记录按关键字的逆序进行排列，此时，每一趟冒泡排序需进行$i$次比较，$3i$次移动。经过$n−1$趟冒泡排序后，总的比较次数为$\sum _{i=1}^{n} i=\frac {n(n−1)}{2}$次, 总的移动次数为$\frac{3n(n−1)}{2}$次，因此该算法的时间复杂度为$O(n^{2})$

另外，冒泡排序法是一种**稳定**的排序方法

---

## 插入排序

一言以蔽之 ： 在一个有序的序列中，将新来的数插入到其中，比如，打牌时的排序(ﾟ▽ﾟ)/


--

### 复杂度

$O(n^{2})$

---

## 选择排序

执行$n - 1$轮，第$i$轮扫描前$n-i + 1$个数，找到最大的数的位置，将其和第$n - i + 1$的位置的数进行交换，也就是放到右边，然后继续。

--

### 复杂度

$O(n^{2})$

---

## 快速排序！

--

一言以蔽之 ： 选择当前待排序序列中的某个数，作为参考值，将其他数中，比这个参考数小的都放在左边，大的都放在右边。现在序列被分成了两个部分。左边比参考值小，右边都比参考值大，然后递归这两部分，进行快速排序。

--

### 复杂度分析

分析快速排序的时间耗费, 共需进行多少趟排序， 取决于递归调用深度。

快速排序所需时间的平均值为 $Tavg(n)≤Knlog(n)$（其中，n为待排序序列中记录的个数，$K$为某个常数。经验表明，在所有同等数量级的此类（先进的）排序方法中，快速排序的常数因子$K$最小，因此，这是目前内部排序方法中所能达到的最好平均时间复杂度。


--

但是若初始记录序列按关键字有序或基本有序时，快速排序将蜕变为冒泡排序，其时间复杂度为$O(n^{2})$。为改进之，可采用其他方法选取枢轴元素，以弥补缺陷。

例如可以采用三者值取中的方法来选取，这里的“三者”通常指的是：r[left]、r[right]、r[(left+right)/2]。“取中”的实现通常是取三者的统计学意义“中值”。

--

**不稳定**

-- 

### 代码

```c++
int a[maxn];
int b[maxn];
void quick_sort(int l,int r)
{
	if(r - l <= 0)return;
	int now = a[l];
	int p = l,q = r;
	for(int i = l + 1;i <= r;i++){
		if(a[i] <= now)b[p++] = a[i];
		else b[q--] = a[i];
	}
	b[p] = now;
	for(int i = l;i <= r;i++){
		a[i] = b[i];
	}
	quick_sort(l , p - 1);
	quick_sort(p + 1 , r);
}
```

---

## 归并排序！

--

将两个或两个以上有序表合并成一个新的有序表。

--

假设初始序列含有n个记录，首先将这n个记录看成n个有序的子序列，每个子序列的长度为1，然后两两归并，得到个长度为2（n为奇数时，最后一个序列的长度为1）的有序子序列；在此基础上，再进行两两归并，如此重复，直至得到一个长度为n的有序序列为止。

--

举个例子 ： 19，13，5，27，1，26，31，16

--

### 复杂度分析

递归深度 ： $log(n)$

每层 ： $n$

复杂度 ： $O(nlogn)$

**稳定**

--

### 代码

```c++
int a[maxn];
int b[maxn];
void merge_sort(int l,int r)
{
	if(r - l <= 0)return ;
	int mid = (l + r) >> 1;
	int p = l,q = mid + 1;
	int pos = l;
	merge_sort(l , mid);
	merge_sort(mid + 1,r);
	while(p <= mid || q <= r)
	{
		
		if(q > r || (p <= mid && a[p] < a[q])){
			b[pos++] = a[p++];
		}else{
			b[pos++] = a[q++];
		}
	}
	for(int i = l;i <= r;i++){
		a[i] = b[i];
	}
}
```

--

### 逆序对

在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。

冒牌排序时，交换次数，就是逆序对数
**归并排序可以$O(nlogn)$求逆序对**，每层递归合并的时候统计一下就行

---

## 计数排序

--

时间换空间

---

## 基数排序

--

按位排序/多关键字排序

--

以10进制，最大三位数为例，先统一成三位数，不足补0。先根据个位数将其分类、排序，再根据十位数，分类、排序，再根据百位数，分类排序

--

复杂度 ： 对于$n$个记录（每个记录含$d$个子关键字，每个子关键字的取值范围为$RADIX$个值）进行链式排序的时间复杂度为$O(d(n+RADIX))$





--



# 有没有一种简单好用的方式来排序呢？

--

有接口，但是这节课我希望大家先自己练习一下一些排序的写法，等讲题的时候我再讲实际应用中的做法。

---

# 排序不只有从小到大和从大到小

--

例3 ： 给定$N$个字符串，类似的定义每个字符串有一个逆序对数，按照每个字符串的逆序对数，将这$n$个字符串从小到大排序

--

例4：二维平面的$n$个点，按照x坐标从小到大排序，如果x相同，则按照y坐标从大到小排序

--

例5 ： 给一个序列，先输出奇数，再输出偶数，奇数从小到大，偶数从大到小

--

例6 ： 排序扑克牌，给n张扑克牌，先按照花色（依次是红桃、方片、黑桃、梅花）排序，相同花色再再按照3、4、5、6、7、8、9、10、J、Q、K、A排序


---

# 字典序

---

# end


